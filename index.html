<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>English TTS (SpeechSynthesis)</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    textarea { width: 100%; height: 180px; font-size: 16px; }
    button, select { font-size: 16px; padding: 10px 14px; margin-right: 8px; }
    .row { margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    pre { background: #f5f5f5; padding: 12px; overflow: auto; }
    .small { font-size: 13px; color: #444; }
    .box { margin-top: 14px; }
  </style>
</head>
<body>
  <h2>English TTS</h2>

  <textarea id="t">This is a test program for tts. Please enter any text in this field.</textarea>

  <div class="row">
    <button id="speak">Speak</button>
    <button id="stop">Stop</button>

    <label class="small" for="voiceSelect">Voice:</label>
    <select id="voiceSelect"></select>

    <button id="refresh">Refresh Voices</button>
  </div>

  <div class="box">
    <div class="small">Voices visible to this browser (name | lang | localService):</div>
    <pre id="voicesOut">(loading...)</pre>
  </div>

  <script>
    const voiceSelect = document.getElementById('voiceSelect');
    const voicesOut = document.getElementById('voicesOut');

    function isEnglish(v) {
      const lang = (v.lang || '').toLowerCase();
      return lang.startsWith('en');
    }

    function loadVoices() {
      const voices = speechSynthesis.getVoices() || [];

      // 表示
      const lines = voices.map(v => {
        const local = v.localService ? 'local' : 'remote';
        return `${v.name} | ${v.lang} | ${local}`;
      });
      voicesOut.textContent =
        `Total voices: ${voices.length}\n` +
        `English voices: ${voices.filter(isEnglish).length}\n\n` +
        (lines.join('\n') || '(no voices)');

      // セलेकト（英語優先、なければ全部）
      voiceSelect.innerHTML = '';
      const list = voices.filter(isEnglish);
      const useList = list.length ? list : voices;

      useList.forEach((v, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = `${v.name} (${v.lang})`;
        opt.dataset.name = v.name;
        opt.dataset.lang = v.lang;
        voiceSelect.appendChild(opt);
      });
    }

    function getSelectedVoice() {
      const voices = speechSynthesis.getVoices() || [];
      const opts = voiceSelect.options;
      if (!opts.length) return null;

      const chosen = opts[voiceSelect.selectedIndex];
      const name = chosen.dataset.name;
      const lang = chosen.dataset.lang;

      return voices.find(v => v.name === name && v.lang === lang) || null;
    }

    function speak() {
      const text = document.getElementById('t').value.trim();
      if (!text) return;

      speechSynthesis.cancel();

      const u = new SpeechSynthesisUtterance(text);

      // 選択した声を使う（見つからなければ en-US 指定だけ）
      const v = getSelectedVoice();
      if (v) {
        u.voice = v;
        u.lang = v.lang || "en-US";
      } else {
        u.lang = "en-US";
      }

      speechSynthesis.speak(u);
    }

    document.getElementById('speak').addEventListener('click', speak);
    document.getElementById('stop').addEventListener('click', () => speechSynthesis.cancel());
    document.getElementById('refresh').addEventListener('click', loadVoices);

    // iOS含め、声が後から入ることがある
    window.speechSynthesis.onvoiceschanged = () => loadVoices();

    // 初回ロード
    loadVoices();
    // 念のため少し後にも再ロード
    setTimeout(loadVoices, 500);
    setTimeout(loadVoices, 1500);
  </script>
</body>
</html>
